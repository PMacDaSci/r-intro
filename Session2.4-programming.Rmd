---
title: "Introduction to Solving Biological Problems Using R - Day 2"
author: PMacDaSci's modified version of material by Mark Dunning, Suraj Menon and Aiora Zabala, Robert StojniÄ,
  Laurent Gatto, Rob Foy, John Davey, DÃ¡vid MolnÃ¡r and Ian Roberts (original material https://github.com/cambiotraining/r-intro).
date: '`r format(Sys.time(), "Last modified: %d %b %Y")`'
output:
  html_document:
    df_print: paged
    toc: yes
  html_notebook:
    toc: yes
    toc_float: yes
---

```{r, message=FALSE}
library(dplyr)
library(ggplot2)
library(RColorBrewer)
```


#4. Programming in R

## Motivation
Typically when we perform an analysis we want to perform the same analysis/steps on either multiple genes/samples/datasets.

With the basic analysis and graphs that we have created in the previous sessions it is possible to
copy and paste the relevant section of code and adjust the code.

However, consider the scenario where you have a script of several hundred lines to anaysis a patient/
dataset.

Whilst you could copy that script and adjust the variables for each patient/dataset. However,
this method of copying, pasting and adjusting can be:
    1. Tedious
    2. Erroreous
    

## Copy/Paste/Edit example
Take the scenario where you want to identify the number of the genes on the 
following chromosomes:  
        Chromosomes 1, 5, 6, 8
```{r}
patients <-  read.delim("updated.patient.txt", stringsAsFactors = FALSE)
exprsAnno <- read.delim("anno.gene.expression.txt", stringsAsFactors = FALSE)
### Insert your code here ###
```

```{r, eval=FALSE, echo=FALSE}
exprsAnno %>%
    filter(Chromosome == "chr1") %>% 
    summarise(n())
```

## Loops: Commands and flow control
- Many programming languages have ways of doing the same thing many times, perhaps changing some variable each time. This is called **looping**

- As we are doing the same thing multiple times, but with a different index each time, we can use a **loop** instead
- R has two basic types of loop
    + a **`while`** loop: run some code while some condition is true 
    (*hardly ever used! Therefore will not be covered*)
    + a **`for`** loop: run some code on every value in a vector
    
`for` 
The basic structure of a `for` loop:
```
for (element in vector){
    ... do this ...
}

```

- Therefore the code is only run for as many elements are in the vector. Therefore we can predict the number of times the code is run

- Note: *element* and *vector* are just variable names and can therefore be named whatever you want
them to be, as long as they satisfy the constriants on varible naming.

- Here's how we might use a `for` loop to find out the number of genes on each chromosome.

```{r}
chrom <- c("chr1", "chr5", "chr6", "chr8")

for (chr in chrom){
    numRows <- exprsAnno %>%
        filter(Chromosome == chr) %>%
        summarise(n())
    print(numRows)
}

```

- The above for loop finds out the same information that we identified earlier by
copying/pasting/editting
- Though the more accurately depict the operations of a `for` loop the code is more similar to the
following:
```{r}
chr <- "chr1"
numRows <- exprsAnno %>% filter(Chromosome == chr) %>% summarise(n())

chr <- "chr5"
numRows <- exprsAnno %>% filter(Chromosome == chr) %>% summarise(n())

chr <- "chr6"
numRows <- exprsAnno %>% filter(Chromosome == chr) %>% summarise(n())

chr <- "chr8"
numRows <- exprsAnno %>% filter(Chromosome == chr) %>% summarise(n())
```

## Exercise
Find the number of patients who are aged above 20, 30, 40, and print the answer to the console.
```{r}
ages <- c(20, 30, 40)
### Insert your code here ###
```
```{r, eval=FALSE, echo=FALSE}
for (a in ages){
    numRows <- patients %>%
        filter(age > a) %>%
        summarise(n())
    print(numRows)
}
```

## Storing results

Note that this `for` loop is helping us identify the number of genes in each chromosome but the
result is not stored. Thus, we can not access the results at a later time.

- When storing the results from a loop, we often create an empty variable before starting the for loop
- This is used store the result at each iteration of the loop

```{r}
numGenes <- NULL
chrom <- c("chr1", "chr5", "chr6", "chr8")
for(chr in chrom) {
  numRows <- exprsAnno %>%
      filter(Chromosome == chr) %>%
      summarise(n())
  numGenes[i] <- numRows
  }
numGenes
```


## Exercise
Identify the number of patients who are positive for ER/PR/HER2 when considering each status
individually. Store the results in a vector.

```{r}
status <- c("er", "pr", "her2")
### Your answer here ###
```
```{r, eval=FALSE, echo=FALSE}
status <- c("er", "pr", "her2")

for (stat in status){
    numRows <- patients %>%
        select(stat) %>%
        filter(. == 1) %>% 
        summarise()
    print(numRows)
}
```


##Conditional branching: Commands and flow control

- Use an `if` statement for any kind of condition testing
- Different outcomes can be selected based on a condition within brackets

```
if (condition) {
  ... do this ...
  } else {
    ... do something else ...
    }
```

- `condition` is any logical value, and can contain multiple conditions. 
    + e.g. `(a == 2 & b < 5)`, this is a compound conditional argument
- The condition should return a *single* value of `TRUE` or `FALSE`
    
## Other conditional tests

- There are various tests that can check the type of data stored in a variable
    + these tend to be called **`is...()`**. 
        + try *tab-complete* on `is.`

```{r}
is.numeric(10)
is.numeric("TEN")
is.character(10)
```

- `is.na()` is useful for seeing if an `NA` value is found
    + cannot use `== NA`!


```{r}
x <- c(1, 2, NA)
mean(x)
is.na(x)
```
- could be used to check if a gene symbol is found in the data before proceeding with statistical test
    + There are 2 methods that could be used to achieve this
    1. Make uses of the functions `all()` and `any()`
    2. Make use of the function `sum()`
```{r}
## Method 1
if (any(exprsAnno$HUGO.gene.symbol == "PIK3CA")){
    print("PIK3CA is in the dataset")
}else{
    print("PIK3CA is not in the dataset")
}

## Method 2
if (sum(exprsAnno$HUGO.gene.symbol == "PIK3CA") == 1){
    print("PIK3CA is in the dataset")
}else{
    print("PIK3CA is not in the dataset")
}
```
## Exercise 3
Write an `if else` statement to check if the following genes are in the dataset:
BCL2, HOXA9, MAPK1, ARID1A, GATA3, ESR1

Additional challenge: Fill in the conditions and code to get the following print statements, where "n" is the integer number of genes found in the dataset:

Note: condition2 is a **compound** condition
```
if (condition1){
    print("All the genes are in the dataset")
}if else (condition2){
    ...code...
    print("Only n genes are in the dataset")
}else{
    print("None of the genes are in the dataset")
}
```
- `file.exists()`, `dir.exists()` and `dir.create()` are also functions that are useful in `if else` statements


## Combining Loops and Conditional branching

- Using the **`for`** loop we wrote before, we could add some code to plot the expression of each gene
    + a boxplot would be ideal
- However, we might only want plots for genes with a "significant" pvalue
- Here's how we can use an `if` statement to test for this
    + for each iteration of the the loop:
        1. test if the p-value from the test is below 0.05 or not
        2. if the p-value is less than 0.05 make a boxplot
        3. if not, do nothing
        
```{r}
pdf("Chromosome8Genes.pdf")
chr8Genes <- exprsAnno %>% filter(Chromosome == "chr8") %>% select(HUGO.gene.symbol)
for (gene in chr8Genes$HUGO.gene.symbol){
    tmp <- exprsAnno %>%
        filter(HUGO.gene.symbol == gene) %>% 
        select(starts_with("NKI"))
    
    tmp <- data.frame(t(tmp))
    
    colnames(tmp) <- "gene"
    
    testResult <- t.test(as.numeric(tmp[, "gene"]) ~ factor(patients[, "er"]))$p.value
    
    if (testResult < 0.05){
        g <- ggplot(tmp, aes(y = gene, x = factor(patients[, "er"]),
                        fill = factor(patients[, "er"]))) +
            geom_boxplot() +
            scale_fill_manual(values = c("#E69F00", "#56B4E9"),
                              name = "Patient ER status",
                              labels = c("Negative", "Positive")) +
            labs(title = paste("Boxplot of", gene, "between ER +/- patients"),
                 subtitle = paste("P-value: ", testResult),
                 x = "patient status", y = paste(gene, "expression")) + 
            theme(plot.title = element_text(hjust = 0.5),
                  plot.subtitle = element_text(hjust = 0.5))
        print(g)
    }
}
dev.off()

```


## Example: VAF plots
What if we are looking at time lapse data?
```{r}
P1Exprs <- read.delim("time_lapse/patient_1.txt")

P1Exprs %>% 
    na.omit() %>%
    select(timepoint, expression, HUGO.gene.symbol) %>% 
    ggplot(aes(x = timepoint,
               y = expression,
               group = factor(HUGO.gene.symbol),
               colour = factor(HUGO.gene.symbol))) + 
    geom_line() +
    labs(title = "Expression level changes in patient 1 over time") +
    theme(legend.position = "none", plot.title = element_text(hjust = 0.5))


```



## Exercise : VAF plots per chromosome
Using the data for patient_1 in the timelapse folder. Create a line graph of the expression level changes for the genes on each chromosome, and export the graphs into a pdf file named: "Time_Lapse_Expression_changes.pdf". Where each page of the pdf looks like the plot below.

Note: The title of the graph on each page should be changed to reflect the chromosome expression levels that are shown.
Hint: Make use of the function `unique()`


```{r,echo=FALSE}
P1Exprs %>% 
    na.omit() %>%
    filter(Chromosome == "chr8") %>%
    select(timepoint, expression, HUGO.gene.symbol) %>% 
    ggplot(aes(x = timepoint,
               y = expression,
               group = factor(HUGO.gene.symbol),
               colour = factor(HUGO.gene.symbol))) + 
    geom_line() +
    labs(title = paste("Expression level changes in chr8 over time"), colour = "Genes") +
    theme(plot.title = element_text(hjust = 0.5))
```

Additional Challenge: Include an `if else` branch, so that the plot is only generated if there are more than 30 genes on the chromosome

##Code formatting avoids bugs!
Compare:
```{r eval=FALSE}
f<-26
while(f!=0){
print(letters[f])
f<-f-1}
```
to:
```{r eval=FALSE}
f <- 26
while(f != 0 ){
  print(letters[f])
  f <- f-1
  }
```
- The code between brackets `{}` *always* is *indented*, this clearly separates what is executed once, and what is run multiple times
- Trailing bracket `}` always alone on the line at the same indentation level as the initial bracket `{`
- Use white spaces to divide the horizontal space between units of your code, e.g. around assignments, comparisons


## Writing Functions
# Motivation
Though R has many inbuilt functions, sometimes we will need to perform a calculation or a set number of steps at multiple steps throughout a script.

Things to consider when writng a function:
1. What are in the inputs, and what are the outputs
    - Note: There can only be ONE output
2. What are sequential steps required from the input to the output
3. Which steps need to be "flexible"
    - Consider what aspects of your code are constant vs. the aspects that could change with different inputs
    - The aspects that can change are the typically included as an input to your function


